---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Beskrivande statistik

Datorövning 2 handlar om beräkning av beskrivande statistik i R. Efter övningen ska vi kunna

- Importera data från en excelfil,
- Beräkna lämpliga lägesmått för en variabel,
- Beräkna lämpliga spridningsmått för en variabel,
- Konstruera grafer som jämför två eller flera gruppers läge och spridning.

## Repetition från datorövning 1

När man arbetar i R är det klokt att använda ett avancerat gränssnitt som RStudio och att skriva sin kod i ett separat skript. I RStudio kan man starta ett nytt skript genom *Ctrl + Shift + N*.

Mycket funktionalitet i R ligger i tilläggspaket (*Packages*). Paket måste installeras första gången de används och laddas varje session de används, t.ex.

```{r}
# install.packages("tidyverse") # Installera tidyverse
library(tidyverse)              # Ladda ett paket
```

Objekt skapas med *assign*-pilen `<-`. Det är ett sätt att importera data till R. Det är dock vanligare importera från en extern fil. Mer om det senare.

Vi arbetar nästan alltid med data på tabellformat där variablerna är kolumner och observationerna rader. I gapminder-datan ges raderna av ett land för ett visst år.

```{r, results='hide'}
library(gapminder)
gapminder                       # Skriv ut objektet gapminder
```

Funktioner agerar på objekt och ger något utfall. Här beräknas medeltempot med funktionen `mean()`. Dollartecknet används för att ange en specifik kolumn i dataobjektet. Funktioner styrs av möjliga argument - här används `na.rm` för att ange att saknade värden inte ska tas med i beräkningen

```{r}
mean(gapminder$lifeExp, na.rm = T) # Beräkna medel av lifeExp
```

Funktionerna `filter()` och `select()` kan användas för att välja kolumner och rader. Funktioner kan länkas samman med en pipe `%>%` för att skapa sekvenser av funktioner. Man kan tänka på pipen som *och sen*.

```{r, results='hide'}
gapminder %>%
  filter(country == "Norway", year > 1972) %>%
  select(country, lifeExp)
```

Slutligen tittade vi på grafer med ggplot2-paketet. En ggplot byggs upp med tre grundelar: data, geometrier (grafens objekt och former), och *aesthetics* (utseende och placering av geometrierna). I ett enkelt spridningsdiagram är data två numeriska variabler, geometrierna är punkter, och punkternas placering ges av en x-koordinat och en y-koordinat. Ytterligare *aesthetics* kan vara punkternas färger (`color`) och storlek (`size`).

```{r, results='hide', fig.show='hide'}
dat_small <- gapminder %>% filter(year == 2007)
ggplot(dat_small, aes(gdpPercap, lifeExp, 
                      size = pop, color = continent)) +
  geom_point()
```

## Import av data från en Excelfil

Inom vetenskapen är Excel det vanligaste filformatet för mindre datamängder. Till den här delen ska vi återigen arbeta med data från *Gapminder*.

::: {.exercise name="Excelfil från Canvas"}
Hitta excelfilen *Gapminder.xlsx* på Canvas och ladda ner den. Hitta mappen som filen laddats ned till.
:::

I R kan man läsa in data från en Excel-fil med funktionen `read_excel()` från paketet `readxl`. Som argument till funktionen sätts filens sökväg - dess placering på hårddisken. Stycket nedan importerar från en excelfil som ligger på hårddisken *C:* i mappen *Downloads*, under *User_name*, under *Users*.

```{r, eval = T}
library(readxl)  # Ladda readxl
```


```{r, eval = F}
gapminder <- read_excel("C:/Users/Name/Downloads/Gapminder.xlsx")
# Läs in från en lokal excelfil
gapminder
```

::: {.exercise name="Importera från excelfil"}
Var ligger den nedladdade filen *Gapminder.xlsx*? Gör lämplig ändring i koden ovan för att läsa in data från den filen. Notera att R använder högerlutande snedstreck `/`, så om en kopierad sökväg har vänster-snedstreck måste de ändras. Kontrollera att datan blivit korrekt inläst genom att köra objektnamnet `gapminder`.
:::

En R-session har alltid en grundmapp, ett *Working directory*. Man kan se vilken mapp det är genom att köra

```{r, eval = F}
getwd() # Ange working directory
```

En filsökväg kan anges antingen som en fullständig sökväg, som ovan, eller relativt *working directory*. Om man till exempel har en fil *Gapminder.xlsx* som ligger i en mapp *Data* som i sin tur ligger i *working directory*, kan man importera data från filen med

```{r, eval=F}
gapminder <- read_excel("Data/Gapminder.xlsx")
# Läs in från en lokal excelfil (relativt wd)
gapminder 
```

::: {.exercise name="Working directory"}
Identifiera *working directory* för din nuvarande Rs-session genom att köra `getwd()`.
:::

RStudio har också en inbyggd funktionalitet för att importera data. Man kan hitta den genom att gå till *Environment*-fliken och sedan *Import Dataset*. Det kan vara en bra hjälp, i synnerhet om man vill sätta datatyp för någon specifik kolumn.

Om du inte har tillgång till Canvas kan Gapminder-datan alternativt hämtas från paketet Gapminder.

```{r, eval = F}
# install.packages("gapminder")
library(gapminder)             
gapminder                      
```

## Ändra och skapa nya kolumner med `mutate`

Variabler kan omräknas och nya variabler kan skapas med `mutate`-funktionen. I gapminder-datan finns bnp per capita. Om man vill ha nationell BNP kan man skapa en ny kolumn och beräkna den som bnp per capita gånger populationen.

```{r, results='hide'}
gapminder <- gapminder %>%             # Ta datan, och sen
  mutate(gdp = gdpPercap * pop)        # Beräkna bnp
```

Den inledande delen med `gapminder <-` gör så att utfallet av beräkningen sparas i objektet `gapminder`.
Vi kan skriva ut objektet och se resultatet av beräkningen:

```{r, results='hide'}
gapminder
```

Om man vill skapa en kolumn med mellanrum i namnet måste man skriva namnet inom *backticks* \` för att ange att namnet ska tolkas som en enhet. Jag rekommenderar att undvika mellanrum i kolumnnamn och istället använda stora bokstäver eller understreck för ett nytt ord (`NationalGDP` eller `National_GDP`).

```{r, results='hide'}
gapminder %>% 
  mutate(`National GDP` = gdpPercap * pop)
```

## Sammanfattande lägesmått

Den importerade datan anger medellivslängd, populationsstorlek och bnp per capita per land och år. Vi kan börja med att producera en bubbelgraf över datan - en av de presentationer Gapminder ofta använder. En bubbelgraf är ett spridningsdiagram där punktens storlek beror på en tredje variabel.

```{r, fig.height = 8, fig.show='hide'}
ggplot(gapminder, aes(gdpPercap, lifeExp, 
                      size = pop, color = continent)) +
  geom_point() +
  facet_wrap(~ year)
```

En interaktiv version kan vara bra om man vill identifiera någon specifik punkt.

```{r, eval = F, fig.height = 8}
g <- ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, 
                           color = continent, text = country)) +
  geom_point() +
  facet_wrap(~ year)

# install.packages("plotly")
library(plotly)                        # Ladda paketet plotly
ggplotly(g)                            # Interaktiv graf g
```

Under föreläsningen såg vi exempel på två lägesmått: medelvärdet (egentligen det *aritmetiska* medelvärdet) och medianen. De har bägge enkla funktioner i R: `mean()` respektive `median()`. Vi plockar ut en variabel ur datan och beräknar bägge.

```{r}
gdpPercap <- gapminder$gdpPercap # Skapa en vektor gdpPercap
mean(gdpPercap)                  # Beräkna medelvärdet
median(gdpPercap)                # Beräkna medianen
```

Samma sak kan göras med en pipe `%>%` och `summarise()`.

```{r, results='hide'}
gapminder %>%
  summarise(Mean = mean(gdpPercap),
            Median = median(gdpPercap))
```

::: {.exercise name="Lägesmått av livslängd"}
Gör lämpliga ändringar i exemplet ovan för att beräkna lägesmått för medellivslängd (`lifeExp`).
:::

Den andra lösningen, med en pipe och `summarise()`, kan enkelt utvecklas med ett `group_by()`-steg för att beräkna medel och median per någon grupp, t.ex. per år.

```{r, results='hide'}
gapminder %>%                           # Ta datan, och sen
  group_by(year) %>%                    # gruppera efter år, och
  summarise(Mean = mean(gdpPercap),     # beräkna medelvärde och
            Median = median(gdpPercap)) # medianen av gdpPercap
```

::: {.exercise name="Lägesmått per kontinent"}
Gör lämpliga ändringar i exemplet ovan för att beräkna lägesmått per kontinent. Vad måste läggas till för att också beräkna maximum och minimum per kontinent (funktionerna `max()` och `min()`)?
:::

::: {.exercise name="Upprepade mätningar"}
Finns det några problem med att beräkna medelvärde per kontinent på den här datan?
:::

I vetenskapliga publikationer redovisas medelvärden ofta med ett stapeldiagram. Som exempel ges staplar för medelvärdet av bnp per kontinent för 2007.

```{r, results='hide', fig.show='hide'}
dat_gdp_2007 <- gapminder %>%       # Ta datan, och sen
  filter(year == 2007) %>%          # filtrera för 2007, och sen
  group_by(continent) %>%           # gruppera kontinenter, och
  summarise(Mean = mean(gdpPercap)) # summera med medelvärdet

ggplot(dat_gdp_2007, aes(continent, Mean)) +
  geom_col()                  # Illustrera med kolumner (columns)
```

::: {.exercise name="Graf för livslängd"}
Gör om stapeldiagrammet. Denna gång med livslängd (`lifeExp`) istället för bnp per capita (`gdpPercap`).
:::

## Sammanfattande spridningsmått

Under föreläsningarna såg vi några mått på spridning: varians, standardavvikelse och kvartilavstånd (IQR, *inter-quartile range*). De har alla motsvarande funktioner i R (`var()`, `sd()`, och `IQR()`) som kan användas på samma sätt som funktionerna för lägesmått.

```{r, results='hide'}
gdpPercap <- gapminder$gdpPercap # Skapa en vektor gdpPercap

var(gdpPercap)                   # Beräkna varians
sd(gdpPercap)                    # Beräkna standardavvikelse
IQR(gdpPercap)                   # Beräkna kvartilavstånd
```

Alternativt med en pipe och `summarise()`.

```{r, results='hide'}
gapminder %>%                       # Ta datan, och
  summarise(Var = var(gdpPercap),   # beräkna varians,
            Sd = sd(gdpPercap),     # standardavvikelse,
            IQR = IQR(gdpPercap))   # och kvartilavstånd
```

Lösningen med pipe och `summarise()` kan som tidigare utvecklas med `group_by()`.

```{r, results='hide'}
gapminder %>%
  group_by(year) %>%
  summarise(Varians = var(gdpPercap),
            Standardavvikelse = sd(gdpPercap),
            Kvartilavstånd = IQR(gdpPercap))
```

::: {.exercise name="Graf för livslängd"}
Gör lämpliga ändringar i det sista exempel för att istället beräkna spridningsmått för livslängd.
:::

Vi avslutar med tre vanliga illustrationer av vetenskaplig data - ett linjediagram med felstaplar, ett stapeldiagram med felstaplar, och ett lådagram. För linjediagrammet beräknar vi medelvärdet och spridningsmått för bnp över år och kontinent. Som spridningsmått använder vi *medelfelet*, vilket beräknas som standardavvikelse delat på roten ur antalet observationer.

```{r, results='hide'}
dat_sum <- gapminder %>%
  group_by(year, continent) %>%
  summarise(Mean = mean(gdpPercap),
            SE = sd(gdpPercap) / sqrt(n()))
dat_sum
```

Med `ggplot2` kan vi bygga ett linjediagram med `geom_line()` och lägga till felstaplar med `geom_errorbar()`. Den senare behöver `aes()`-argument för `ymin` och `ymax` - nedre och övre del av felstapeln. Vi sätter dem till medelvärdet minus respektive plus ett medelfel.

```{r, fig.show='hide'}
ggplot(dat_sum, aes(year, Mean, color = continent)) +
  geom_line() +
  geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE))
```

::: {.exercise name="Bredd"}
Felstaplarna från `geom_errorbar()` har väldigt breda ändar. Använd hjälpsidan för geomet `?geom_errorbar`, i synnerhet exemplen längst ned, och se om det går att ändra bredden.
:::

En graf med staplar och felstaplar kan konstrueras på ett liknande sätt. Följande exempel visar staplar över livslängd per kontinent. Felstapeln ges av standardavvikelsen.

```{r, results='hide'}
dat_sum <- gapminder %>%          # Ta datan, och sen
  filter(year == 2007) %>%        # filtrera på år, och sen
  group_by(continent) %>%         # gruppera efter kontinent,
  summarise(Mean = mean(lifeExp), # summera med medelvärde,
            SD = sd(lifeExp))     # och standardavvikelse
dat_sum
```

Vi bygger en ggplot med `geom_col()` och `geom_errorbar()`. Felstapels konstruktion kan anges i en notis med funktionen `labs()`.

```{r, fig.show='hide'}
ggplot(dat_sum, aes(continent, Mean, fill = continent)) +
  geom_col()+                                            
  geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD)) +
  labs(title = "Average life expectancy by continent, 2007",
       caption = "Errorbars given by mean +/- standard deviation.
       Source: Gapminder")
```

::: {.exercise name="Staplar för 1982"}
Gör lämpliga ändringar i exempel ovan för att konstruera ett stapeldiagram med felstaplar för året 1982 och variabeln gdpPercap.
:::

Ett lådagram anger fördelningen av en variabel genom att illustrera minimum, maximum och kvartiler. Kvartiler är mått som delar en datamängd i fyra lika stora delar (så att en fjärdedel ligger under första kvartilen, en fjärdedel mellan första och andra kvartil, och så vidare). Med `ggplot2` kan vi bygga ett lådagram med `geom_boxplot()`. Exempel ger en låda per år och kontinent.

```{r, fig.show='hide'}
ggplot(gapminder, aes(year, lifeExp, fill = continent, 
                      group = year)) +
  geom_boxplot() +                                                     
  facet_wrap(~ continent)                                              
```

::: {.exercise name="Group-argumentet"}
I lådagrammet används argumentet `group`. Vad gör det? Vad händer om man tar bort det?
:::

Om man vill ha med både data på observationsnivån och summerad data i en graf kan man ange olika data till olika geom. Vi kan t.ex. lägga till en markör för medelvärdet i en boxplot.

```{r, results='hide', fig.show='hide'}
gapminder_2007 <- gapminder %>% filter(year == 2007)
gapminder_agg <- gapminder_2007 %>% 
  group_by(continent) %>% 
  summarise(lifeExp = mean(lifeExp))
gapminder_agg

ggplot() +
  geom_boxplot(aes(lifeExp, continent), data = gapminder_2007) +
  geom_point(aes(lifeExp, continent), data = gapminder_agg, 
             color = "red", shape = "X", size = 6)
```

Här byggs boxarna med datan `gapminder` och punkterna med den aggregerade datan.

## Ordna upp beskrivande statistik och exportera

Efter att ha beräknat någon beskrivande statistik kan det vara bra att titta på hur resultaten kan snyggas upp och exporteras i något lämpligt format. Ta den tabell med medelvärden vi producerade i ett tidigare exempel.

```{r, results='hide'}
dat_sum <- gapminder %>%          # Ta datan, och sen
  filter(year == 2007) %>%        # filtrera på år, och sen
  group_by(continent) %>%         # gruppera efter kontinent,
  summarise(Mean = mean(lifeExp), # summera med medelvärde,
            SD = sd(lifeExp))     # och standardavvikelse
dat_sum
```

Objekt kan exporteras från R på liknande som det importeras - med särskilda exportfunktioner (*write*-funktioner) beroende på filtyp. För att exportera till en csv-fil man man använda `write_csv()`. Ingående argument är det objekt man vill exportera och den fil man vill exportera till. R ger ingen varning om man skriver över en existerande fil, så var lite försiktiga här.

Precis som vid import använder R *working directory* om inget annat anges. Följande exporterar objektet `dat_sum` till en csv-fil *Exporterad data från R.csv* i *working directory*.

```{r, eval = F}
getwd()                          # Se nuvarande working directory
write_csv(dat_sum, "Exporterad data från R.csv") # Exportera data
```

Därifrån skulle man kunna öppna filen i något kalkylprogram, snygga till layouten, och sedan klippa in i ett textdokument.

## Kumulativt medelvärde

Om man har data som av någon anledning samlas in i sekvens kan det vara intressant att beräkna och illustrera den med ett *kumulativt medelvärde*. En serie med kumulativa medelvärden beräknas genom att för varje nytt värde ta medelvärden av de värden man hittills samlat in - vid tio värden tar man medelvärdet av de tio, vid elva värden medelvärdet av de elva, och så vidare.

Med de tärningsvärden vi hade innan kan vi beräkna ett kumulativt medelvärde genom att först beräkna summan med `cumsum()` och sedan dela på antalet kast. För att förenkla beräkningen av antalen tar vi fram sekvensen med antal kast i ett `mutate()`-steg.

```{r, results='hide'}
dat_dice <- data.frame(Utfall = c(6,3,2,3,5)) %>%
  mutate(Kast = 1:n())                           
dat_dice

dat_dice <- dat_dice %>%
  mutate(kumulativ_summa = cumsum(Utfall),  
         kumulativt_medelvärde = kumulativ_summa / Kast)
dat_dice
```

Om beräkning inte är uppenbar här, ta någon minut för att förstå den.

::: {.exercise name="Kumulativt medelvärde"}
Vad ska läggas till för att stycket nedan ska ge en linjegraf över medelvärdet?

```{r, eval = F}
ggplot(dat_dice, aes(x = Kast, y = ___)) +
  ___()
```
:::

::: {.exercise name="Fler tärningskast"}
Kasta din tärning ytterligare några gånger, gärna på en mjuk yta. Fyll i dina utfall och gör grafen från föregående uppgift. Kan man se en tendens för medelvärdet att minska i varians vid fler kast?

```{r, eval = F}
dat_dice <- data.frame(Utfall = c(___)) %>% 
  mutate(Kast = 1:n(),                                 
         `Kumulativ summa` = cumsum(Utfall),           
         `Kumulativt medelvärde` = `Kumulativ summa` / Kast)
dat_dice
```
:::

::: {.exercise name="Kumulativ frekvens"}
Om man vill titta på andelen gånger ett visst utfall inträffat talar man om *kumulativ frekvens* snarare än *kumulativt medelvärde*. Använd stycket nedan för att titta på andelen gånger utfallet varit en etta (ett *positivt* utfall, i begreppets kliniska mening). Om ett inte är ett möjligt utfall på din tärning, ändra ettan till något mer lämpligt.

```{r, eval = F}
dat_dice <- data.frame(Utfall = c(___)) %>% 
  mutate(Kast = 1:n(),
         positivt_utfall = Utfall == 1,              
         kumulativt_antal = cumsum(positivt_utfall),
         kumulativ_frekvens = kumulativt_antal / Kast)
dat_dice

ggplot(dat_dice, aes(x = Kast, y = kumulativ_frekvens)) +
  geom_line()
```
:::

## Bonus. Tredimensionella grafer med `plotly`

Paketet `plotly` kan användas för att göra interaktiva graf och grafer med tre dimensioner. Börja med att ladda paketet.

```{r loadPlotly, eval = F}
library(plotly)
```

Vi börjar med ett enkelt exempel på en 3d-graf med lite skapad data.

```{r, eval = F}
dat_ex <- data.frame(Var1 = c(1,2,3), Var2 = c(3,1,2), 
                     Var3 = c(2,3,1), Type = c("A", "B", "C"))
dat_ex

plot_ly(dat_ex, x = ~Var1, y = ~Var2, 
        z = ~Var3, color = ~Type) %>%
  add_markers()
```

Om grafen inte kommer upp direkt kan det fungera att trycka på den lilla ikonen med ett fönster och en pil i *Viewer*-fliken. Grafen ska då öppnas i en webbläsare.

Syntaxen till `plot_ly()` är inte helt olik `ggplot()`. Först anges datan, därefter argument för x- y-, och z-koordinater. Notera tilde-tecknet `~` före variabelnamnen. Eventuell färg sätts med `color`. Efter det lägger man till punkter (här *markers*) med en pipe in i `add_markers()`. Vi vill göra en liknande graf med gapminder-datan, men får börja med att filtrera på ett visst år.

::: {.exercise name="Filtrera för år"}
Vad måste läggas till i funktionen nedan för att filtrera för data där året är 2007?

```{r, eval = F}
dat_2007 <- gapminder %>% 
  ___(year == ___)
```
:::

Vi kan nu konstruera en 3d-graf med datan.

::: {.exercise name="Gapminder i 3d"}
Vad måste läggas till i funktionen nedan för en 3d-graf med befolkningsmängd (`pop`)  på x-axeln, livslängd (`lifeExp`) på y-axeln, bnp per capita (`gdpPercap`) på z-axeln, och färg efter kontinent (`continent`)? För att kunna identifiera specifika länder kan man också sätta argumentet `text`.

```{r, eval = F}
plot_ly(___, x = ~___, y = ~___, z = ~___, 
        color = ~___, text = ~country) %>% 
  add_markers()
```
:::

::: {.exercise name="Log-transformationer"}
Inom statistiken är det vanligt att transformera variabler för att ta bort extremeffekter och visa på specifika dataegenskaper. En vanlig transform är att *logaritmera* ett värde, vilket innebär att man istället för att använda det ursprungliga värdet använder exponenten i någon bas (ofta basen tio). Ta till exempel värdet 10000, dess tio-logaritm är 4, eftersom 10 upphöjt i 4 är 10000. Logaritmer är vanliga vid data med extremvärden.

Grafen i uppgiften ovan präglas mycket av skillnader i bnp och befolkningsstorlek. Testa att tio-logaritmera variablerna och se om det blir en mer eller mindre överskådlig graf. Logaritmen kan göras genom att byta den ursprungliga variabeln mot en variabel transformerad med `log10()`. Fyll i stycket nedan.

```{r, eval = F}
plot_ly(___, x = ~log10(___), y = ~log10(___), 
        z = ~___, color = ~___, text = ~country) %>% 
  add_markers()
```
:::

::: {.exercise name="Följa ett land"}
Likt en ggplot kan man lägga till graf-element. Här använder man dock en pipe för lägga till ett nytt element. Fyll i kodstycket nedan. Vad, om något, har lagts till i grafen?

```{r, eval = F}
plot_ly(___, x = ~log10(___), y = ~log10(___), 
        z = ~___, color = ~___, text = ~country) %>% 
  add_markers() %>% 
  add_lines(data = gapminder %>% filter(country == "Costa Rica"))
```
:::
